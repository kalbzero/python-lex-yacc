Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ASSIGN
    BREAK
    CASE
    COLON
    DEFAULT
    DIVIDE
    DIVIDEEQUALS
    EXPLAMATION
    MINUS
    MINUSEQUALS
    PLUS
    SUMEQUALS
    SWITCH
    TIMES
    TIMESEQUALS

Grammar

Rule 0     S' -> program
Rule 1     program -> sequence_declaration
Rule 2     sequence_declaration -> declaration sequence_declaration
Rule 3     sequence_declaration -> declaration
Rule 4     declaration -> type variavel define_end_of_instruction
Rule 5     declaration -> statement_if
Rule 6     statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE
Rule 7     statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
Rule 8     expression -> condition MAIOR condition
Rule 9     expression -> condition MENOR condition
Rule 10    expression -> condition MAIOREQUALS condition
Rule 11    expression -> condition MENOREQUALS condition
Rule 12    expression -> condition EQUALS condition
Rule 13    expression -> condition DIFF condition
Rule 14    expression -> condition AND condition
Rule 15    expression -> condition OR condition
Rule 16    type -> INT
Rule 17    type -> FLOAT
Rule 18    type -> CHAR
Rule 19    value -> NUMBER
Rule 20    value -> DECIMAL
Rule 21    value -> STRING
Rule 22    condition -> type
Rule 23    condition -> value
Rule 24    variavel -> ID
Rule 25    variavel -> ID COMMA variavel
Rule 26    define_end_of_instruction -> SEMICOLON

Terminals, with rules where they appear

AND                  : 14
ASSIGN               : 
BREAK                : 
CASE                 : 
CHAR                 : 18
COLON                : 
COMMA                : 25
DECIMAL              : 20
DEFAULT              : 
DIFF                 : 13
DIVIDE               : 
DIVIDEEQUALS         : 
ELSE                 : 7
EQUALS               : 12
EXPLAMATION          : 
FLOAT                : 17
ID                   : 24 25
IF                   : 6 7
INT                  : 16
LBRACE               : 6 7 7
LPAREN               : 6 7
MAIOR                : 8
MAIOREQUALS          : 10
MENOR                : 9
MENOREQUALS          : 11
MINUS                : 
MINUSEQUALS          : 
NUMBER               : 19
OR                   : 15
PLUS                 : 
RBRACE               : 6 7 7
RPAREN               : 6 7
SEMICOLON            : 26
STRING               : 21
SUMEQUALS            : 
SWITCH               : 
TIMES                : 
TIMESEQUALS          : 
error                : 

Nonterminals, with rules where they appear

condition            : 8 8 9 9 10 10 11 11 12 12 13 13 14 14 15 15
declaration          : 2 3 6 7 7
define_end_of_instruction : 4
expression           : 6 7
program              : 0
sequence_declaration : 1 2
statement_if         : 5
type                 : 4 22
value                : 23
variavel             : 4 25

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . sequence_declaration
    (2) sequence_declaration -> . declaration sequence_declaration
    (3) sequence_declaration -> . declaration
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . statement_if
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (6) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (7) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    IF              shift and go to state 9

    program                        shift and go to state 1
    sequence_declaration           shift and go to state 2
    declaration                    shift and go to state 3
    type                           shift and go to state 4
    statement_if                   shift and go to state 5

state 1

    (0) S' -> program .



state 2

    (1) program -> sequence_declaration .

    $end            reduce using rule 1 (program -> sequence_declaration .)


state 3

    (2) sequence_declaration -> declaration . sequence_declaration
    (3) sequence_declaration -> declaration .
    (2) sequence_declaration -> . declaration sequence_declaration
    (3) sequence_declaration -> . declaration
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . statement_if
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (6) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (7) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE

    $end            reduce using rule 3 (sequence_declaration -> declaration .)
    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    IF              shift and go to state 9

    declaration                    shift and go to state 3
    sequence_declaration           shift and go to state 10
    type                           shift and go to state 4
    statement_if                   shift and go to state 5

state 4

    (4) declaration -> type . variavel define_end_of_instruction
    (24) variavel -> . ID
    (25) variavel -> . ID COMMA variavel

    ID              shift and go to state 12

    variavel                       shift and go to state 11

state 5

    (5) declaration -> statement_if .

    INT             reduce using rule 5 (declaration -> statement_if .)
    FLOAT           reduce using rule 5 (declaration -> statement_if .)
    CHAR            reduce using rule 5 (declaration -> statement_if .)
    IF              reduce using rule 5 (declaration -> statement_if .)
    $end            reduce using rule 5 (declaration -> statement_if .)
    RBRACE          reduce using rule 5 (declaration -> statement_if .)


state 6

    (16) type -> INT .

    ID              reduce using rule 16 (type -> INT .)
    MAIOR           reduce using rule 16 (type -> INT .)
    MENOR           reduce using rule 16 (type -> INT .)
    MAIOREQUALS     reduce using rule 16 (type -> INT .)
    MENOREQUALS     reduce using rule 16 (type -> INT .)
    EQUALS          reduce using rule 16 (type -> INT .)
    DIFF            reduce using rule 16 (type -> INT .)
    AND             reduce using rule 16 (type -> INT .)
    OR              reduce using rule 16 (type -> INT .)
    RPAREN          reduce using rule 16 (type -> INT .)


state 7

    (17) type -> FLOAT .

    ID              reduce using rule 17 (type -> FLOAT .)
    MAIOR           reduce using rule 17 (type -> FLOAT .)
    MENOR           reduce using rule 17 (type -> FLOAT .)
    MAIOREQUALS     reduce using rule 17 (type -> FLOAT .)
    MENOREQUALS     reduce using rule 17 (type -> FLOAT .)
    EQUALS          reduce using rule 17 (type -> FLOAT .)
    DIFF            reduce using rule 17 (type -> FLOAT .)
    AND             reduce using rule 17 (type -> FLOAT .)
    OR              reduce using rule 17 (type -> FLOAT .)
    RPAREN          reduce using rule 17 (type -> FLOAT .)


state 8

    (18) type -> CHAR .

    ID              reduce using rule 18 (type -> CHAR .)
    MAIOR           reduce using rule 18 (type -> CHAR .)
    MENOR           reduce using rule 18 (type -> CHAR .)
    MAIOREQUALS     reduce using rule 18 (type -> CHAR .)
    MENOREQUALS     reduce using rule 18 (type -> CHAR .)
    EQUALS          reduce using rule 18 (type -> CHAR .)
    DIFF            reduce using rule 18 (type -> CHAR .)
    AND             reduce using rule 18 (type -> CHAR .)
    OR              reduce using rule 18 (type -> CHAR .)
    RPAREN          reduce using rule 18 (type -> CHAR .)


state 9

    (6) statement_if -> IF . LPAREN expression RPAREN LBRACE declaration RBRACE
    (7) statement_if -> IF . LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE

    LPAREN          shift and go to state 13


state 10

    (2) sequence_declaration -> declaration sequence_declaration .

    $end            reduce using rule 2 (sequence_declaration -> declaration sequence_declaration .)


state 11

    (4) declaration -> type variavel . define_end_of_instruction
    (26) define_end_of_instruction -> . SEMICOLON

    SEMICOLON       shift and go to state 15

    define_end_of_instruction      shift and go to state 14

state 12

    (24) variavel -> ID .
    (25) variavel -> ID . COMMA variavel

    SEMICOLON       reduce using rule 24 (variavel -> ID .)
    COMMA           shift and go to state 16


state 13

    (6) statement_if -> IF LPAREN . expression RPAREN LBRACE declaration RBRACE
    (7) statement_if -> IF LPAREN . expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
    (8) expression -> . condition MAIOR condition
    (9) expression -> . condition MENOR condition
    (10) expression -> . condition MAIOREQUALS condition
    (11) expression -> . condition MENOREQUALS condition
    (12) expression -> . condition EQUALS condition
    (13) expression -> . condition DIFF condition
    (14) expression -> . condition AND condition
    (15) expression -> . condition OR condition
    (22) condition -> . type
    (23) condition -> . value
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (19) value -> . NUMBER
    (20) value -> . DECIMAL
    (21) value -> . STRING

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    NUMBER          shift and go to state 21
    DECIMAL         shift and go to state 22
    STRING          shift and go to state 23

    expression                     shift and go to state 17
    condition                      shift and go to state 18
    type                           shift and go to state 19
    value                          shift and go to state 20

state 14

    (4) declaration -> type variavel define_end_of_instruction .

    INT             reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    FLOAT           reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    CHAR            reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    IF              reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    $end            reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    RBRACE          reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)


state 15

    (26) define_end_of_instruction -> SEMICOLON .

    INT             reduce using rule 26 (define_end_of_instruction -> SEMICOLON .)
    FLOAT           reduce using rule 26 (define_end_of_instruction -> SEMICOLON .)
    CHAR            reduce using rule 26 (define_end_of_instruction -> SEMICOLON .)
    IF              reduce using rule 26 (define_end_of_instruction -> SEMICOLON .)
    $end            reduce using rule 26 (define_end_of_instruction -> SEMICOLON .)
    RBRACE          reduce using rule 26 (define_end_of_instruction -> SEMICOLON .)


state 16

    (25) variavel -> ID COMMA . variavel
    (24) variavel -> . ID
    (25) variavel -> . ID COMMA variavel

    ID              shift and go to state 12

    variavel                       shift and go to state 24

state 17

    (6) statement_if -> IF LPAREN expression . RPAREN LBRACE declaration RBRACE
    (7) statement_if -> IF LPAREN expression . RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE

    RPAREN          shift and go to state 25


state 18

    (8) expression -> condition . MAIOR condition
    (9) expression -> condition . MENOR condition
    (10) expression -> condition . MAIOREQUALS condition
    (11) expression -> condition . MENOREQUALS condition
    (12) expression -> condition . EQUALS condition
    (13) expression -> condition . DIFF condition
    (14) expression -> condition . AND condition
    (15) expression -> condition . OR condition

    MAIOR           shift and go to state 26
    MENOR           shift and go to state 27
    MAIOREQUALS     shift and go to state 28
    MENOREQUALS     shift and go to state 29
    EQUALS          shift and go to state 30
    DIFF            shift and go to state 31
    AND             shift and go to state 32
    OR              shift and go to state 33


state 19

    (22) condition -> type .

    MAIOR           reduce using rule 22 (condition -> type .)
    MENOR           reduce using rule 22 (condition -> type .)
    MAIOREQUALS     reduce using rule 22 (condition -> type .)
    MENOREQUALS     reduce using rule 22 (condition -> type .)
    EQUALS          reduce using rule 22 (condition -> type .)
    DIFF            reduce using rule 22 (condition -> type .)
    AND             reduce using rule 22 (condition -> type .)
    OR              reduce using rule 22 (condition -> type .)
    RPAREN          reduce using rule 22 (condition -> type .)


state 20

    (23) condition -> value .

    MAIOR           reduce using rule 23 (condition -> value .)
    MENOR           reduce using rule 23 (condition -> value .)
    MAIOREQUALS     reduce using rule 23 (condition -> value .)
    MENOREQUALS     reduce using rule 23 (condition -> value .)
    EQUALS          reduce using rule 23 (condition -> value .)
    DIFF            reduce using rule 23 (condition -> value .)
    AND             reduce using rule 23 (condition -> value .)
    OR              reduce using rule 23 (condition -> value .)
    RPAREN          reduce using rule 23 (condition -> value .)


state 21

    (19) value -> NUMBER .

    MAIOR           reduce using rule 19 (value -> NUMBER .)
    MENOR           reduce using rule 19 (value -> NUMBER .)
    MAIOREQUALS     reduce using rule 19 (value -> NUMBER .)
    MENOREQUALS     reduce using rule 19 (value -> NUMBER .)
    EQUALS          reduce using rule 19 (value -> NUMBER .)
    DIFF            reduce using rule 19 (value -> NUMBER .)
    AND             reduce using rule 19 (value -> NUMBER .)
    OR              reduce using rule 19 (value -> NUMBER .)
    RPAREN          reduce using rule 19 (value -> NUMBER .)


state 22

    (20) value -> DECIMAL .

    MAIOR           reduce using rule 20 (value -> DECIMAL .)
    MENOR           reduce using rule 20 (value -> DECIMAL .)
    MAIOREQUALS     reduce using rule 20 (value -> DECIMAL .)
    MENOREQUALS     reduce using rule 20 (value -> DECIMAL .)
    EQUALS          reduce using rule 20 (value -> DECIMAL .)
    DIFF            reduce using rule 20 (value -> DECIMAL .)
    AND             reduce using rule 20 (value -> DECIMAL .)
    OR              reduce using rule 20 (value -> DECIMAL .)
    RPAREN          reduce using rule 20 (value -> DECIMAL .)


state 23

    (21) value -> STRING .

    MAIOR           reduce using rule 21 (value -> STRING .)
    MENOR           reduce using rule 21 (value -> STRING .)
    MAIOREQUALS     reduce using rule 21 (value -> STRING .)
    MENOREQUALS     reduce using rule 21 (value -> STRING .)
    EQUALS          reduce using rule 21 (value -> STRING .)
    DIFF            reduce using rule 21 (value -> STRING .)
    AND             reduce using rule 21 (value -> STRING .)
    OR              reduce using rule 21 (value -> STRING .)
    RPAREN          reduce using rule 21 (value -> STRING .)


state 24

    (25) variavel -> ID COMMA variavel .

    SEMICOLON       reduce using rule 25 (variavel -> ID COMMA variavel .)


state 25

    (6) statement_if -> IF LPAREN expression RPAREN . LBRACE declaration RBRACE
    (7) statement_if -> IF LPAREN expression RPAREN . LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE

    LBRACE          shift and go to state 34


state 26

    (8) expression -> condition MAIOR . condition
    (22) condition -> . type
    (23) condition -> . value
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (19) value -> . NUMBER
    (20) value -> . DECIMAL
    (21) value -> . STRING

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    NUMBER          shift and go to state 21
    DECIMAL         shift and go to state 22
    STRING          shift and go to state 23

    condition                      shift and go to state 35
    type                           shift and go to state 19
    value                          shift and go to state 20

state 27

    (9) expression -> condition MENOR . condition
    (22) condition -> . type
    (23) condition -> . value
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (19) value -> . NUMBER
    (20) value -> . DECIMAL
    (21) value -> . STRING

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    NUMBER          shift and go to state 21
    DECIMAL         shift and go to state 22
    STRING          shift and go to state 23

    condition                      shift and go to state 36
    type                           shift and go to state 19
    value                          shift and go to state 20

state 28

    (10) expression -> condition MAIOREQUALS . condition
    (22) condition -> . type
    (23) condition -> . value
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (19) value -> . NUMBER
    (20) value -> . DECIMAL
    (21) value -> . STRING

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    NUMBER          shift and go to state 21
    DECIMAL         shift and go to state 22
    STRING          shift and go to state 23

    condition                      shift and go to state 37
    type                           shift and go to state 19
    value                          shift and go to state 20

state 29

    (11) expression -> condition MENOREQUALS . condition
    (22) condition -> . type
    (23) condition -> . value
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (19) value -> . NUMBER
    (20) value -> . DECIMAL
    (21) value -> . STRING

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    NUMBER          shift and go to state 21
    DECIMAL         shift and go to state 22
    STRING          shift and go to state 23

    condition                      shift and go to state 38
    type                           shift and go to state 19
    value                          shift and go to state 20

state 30

    (12) expression -> condition EQUALS . condition
    (22) condition -> . type
    (23) condition -> . value
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (19) value -> . NUMBER
    (20) value -> . DECIMAL
    (21) value -> . STRING

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    NUMBER          shift and go to state 21
    DECIMAL         shift and go to state 22
    STRING          shift and go to state 23

    condition                      shift and go to state 39
    type                           shift and go to state 19
    value                          shift and go to state 20

state 31

    (13) expression -> condition DIFF . condition
    (22) condition -> . type
    (23) condition -> . value
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (19) value -> . NUMBER
    (20) value -> . DECIMAL
    (21) value -> . STRING

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    NUMBER          shift and go to state 21
    DECIMAL         shift and go to state 22
    STRING          shift and go to state 23

    condition                      shift and go to state 40
    type                           shift and go to state 19
    value                          shift and go to state 20

state 32

    (14) expression -> condition AND . condition
    (22) condition -> . type
    (23) condition -> . value
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (19) value -> . NUMBER
    (20) value -> . DECIMAL
    (21) value -> . STRING

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    NUMBER          shift and go to state 21
    DECIMAL         shift and go to state 22
    STRING          shift and go to state 23

    condition                      shift and go to state 41
    type                           shift and go to state 19
    value                          shift and go to state 20

state 33

    (15) expression -> condition OR . condition
    (22) condition -> . type
    (23) condition -> . value
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (19) value -> . NUMBER
    (20) value -> . DECIMAL
    (21) value -> . STRING

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    NUMBER          shift and go to state 21
    DECIMAL         shift and go to state 22
    STRING          shift and go to state 23

    condition                      shift and go to state 42
    type                           shift and go to state 19
    value                          shift and go to state 20

state 34

    (6) statement_if -> IF LPAREN expression RPAREN LBRACE . declaration RBRACE
    (7) statement_if -> IF LPAREN expression RPAREN LBRACE . declaration RBRACE ELSE LBRACE declaration RBRACE
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . statement_if
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (6) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (7) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    IF              shift and go to state 9

    declaration                    shift and go to state 43
    type                           shift and go to state 4
    statement_if                   shift and go to state 5

state 35

    (8) expression -> condition MAIOR condition .

    RPAREN          reduce using rule 8 (expression -> condition MAIOR condition .)


state 36

    (9) expression -> condition MENOR condition .

    RPAREN          reduce using rule 9 (expression -> condition MENOR condition .)


state 37

    (10) expression -> condition MAIOREQUALS condition .

    RPAREN          reduce using rule 10 (expression -> condition MAIOREQUALS condition .)


state 38

    (11) expression -> condition MENOREQUALS condition .

    RPAREN          reduce using rule 11 (expression -> condition MENOREQUALS condition .)


state 39

    (12) expression -> condition EQUALS condition .

    RPAREN          reduce using rule 12 (expression -> condition EQUALS condition .)


state 40

    (13) expression -> condition DIFF condition .

    RPAREN          reduce using rule 13 (expression -> condition DIFF condition .)


state 41

    (14) expression -> condition AND condition .

    RPAREN          reduce using rule 14 (expression -> condition AND condition .)


state 42

    (15) expression -> condition OR condition .

    RPAREN          reduce using rule 15 (expression -> condition OR condition .)


state 43

    (6) statement_if -> IF LPAREN expression RPAREN LBRACE declaration . RBRACE
    (7) statement_if -> IF LPAREN expression RPAREN LBRACE declaration . RBRACE ELSE LBRACE declaration RBRACE

    RBRACE          shift and go to state 44


state 44

    (6) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .
    (7) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE . ELSE LBRACE declaration RBRACE

    INT             reduce using rule 6 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    FLOAT           reduce using rule 6 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    CHAR            reduce using rule 6 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    IF              reduce using rule 6 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    $end            reduce using rule 6 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    RBRACE          reduce using rule 6 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    ELSE            shift and go to state 45


state 45

    (7) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE . LBRACE declaration RBRACE

    LBRACE          shift and go to state 46


state 46

    (7) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE . declaration RBRACE
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . statement_if
    (16) type -> . INT
    (17) type -> . FLOAT
    (18) type -> . CHAR
    (6) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (7) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE

    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    CHAR            shift and go to state 8
    IF              shift and go to state 9

    declaration                    shift and go to state 47
    type                           shift and go to state 4
    statement_if                   shift and go to state 5

state 47

    (7) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration . RBRACE

    RBRACE          shift and go to state 48


state 48

    (7) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .

    INT             reduce using rule 7 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    FLOAT           reduce using rule 7 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    CHAR            reduce using rule 7 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    IF              reduce using rule 7 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    $end            reduce using rule 7 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    RBRACE          reduce using rule 7 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)

