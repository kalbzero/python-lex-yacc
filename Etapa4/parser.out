Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DIVIDEEQUALS
    EXPLAMATION
    MINUSEQUALS
    SUMEQUALS
    TIMESEQUALS

Grammar

Rule 0     S' -> program
Rule 1     program -> sequence_declaration
Rule 2     sequence_declaration -> declaration sequence_declaration
Rule 3     sequence_declaration -> declaration
Rule 4     declaration -> type variavel define_end_of_instruction
Rule 5     declaration -> op_math
Rule 6     declaration -> statement_if
Rule 7     declaration -> statement_switch
Rule 8     declaration -> statement_for
Rule 9     declaration -> statement_while
Rule 10    statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE
Rule 11    statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
Rule 12    statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE
Rule 13    define_cases -> CASE value COLON LBRACE declaration define_break RBRACE
Rule 14    define_cases -> CASE value COLON LBRACE declaration define_break RBRACE define_cases
Rule 15    define_default -> DEFAULT COLON LBRACE declaration define_break RBRACE
Rule 16    statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE
Rule 17    statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
Rule 18    condition_for -> INT ID ASSIGN NUMBER define_end_of_instruction expression define_end_of_instruction alter_value define_end_of_instruction
Rule 19    alter_value -> ID PLUS PLUS
Rule 20    alter_value -> PLUS PLUS ID
Rule 21    alter_value -> ID MINUS MINUS
Rule 22    alter_value -> MINUS MINUS ID
Rule 23    op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math
Rule 24    op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math
Rule 25    op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math
Rule 26    op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
Rule 27    op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction
Rule 28    op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction
Rule 29    op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction
Rule 30    op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction
Rule 31    expression -> condition MAIOR condition
Rule 32    expression -> condition MENOR condition
Rule 33    expression -> condition MAIOREQUALS condition
Rule 34    expression -> condition MENOREQUALS condition
Rule 35    expression -> condition EQUALS condition
Rule 36    expression -> condition DIFF condition
Rule 37    expression -> condition AND condition
Rule 38    expression -> condition OR condition
Rule 39    type -> INT
Rule 40    type -> FLOAT
Rule 41    type -> CHAR
Rule 42    value -> NUMBER
Rule 43    value -> DECIMAL
Rule 44    value -> STRING
Rule 45    condition -> ID
Rule 46    condition -> value
Rule 47    variavel -> ID
Rule 48    variavel -> ID COMMA variavel
Rule 49    variavel -> ID ASSIGN value
Rule 50    variavel -> ID ASSIGN value COMMA variavel
Rule 51    define_end_of_instruction -> SEMICOLON
Rule 52    define_break -> BREAK define_end_of_instruction

Terminals, with rules where they appear

AND                  : 37
ASSIGN               : 18 23 24 25 26 27 28 29 30 49 50
BREAK                : 52
CASE                 : 13 14
CHAR                 : 41
COLON                : 13 14 15
COMMA                : 48 50
DECIMAL              : 43
DEFAULT              : 15
DIFF                 : 36
DIVIDE               : 26 30
DIVIDEEQUALS         : 
ELSE                 : 11
EQUALS               : 35
EXPLAMATION          : 
FLOAT                : 40
FOR                  : 17
ID                   : 12 18 19 20 21 22 23 23 23 24 24 24 25 25 25 26 26 26 27 27 27 28 28 28 29 29 29 30 30 30 45 47 48 49 50
IF                   : 10 11
INT                  : 18 39
LBRACE               : 10 11 11 12 13 14 15 16 17
LPAREN               : 10 11 12 16 17
MAIOR                : 31
MAIOREQUALS          : 33
MENOR                : 32
MENOREQUALS          : 34
MINUS                : 21 21 22 22 24 28
MINUSEQUALS          : 
NUMBER               : 18 42
OR                   : 38
PLUS                 : 19 19 20 20 23 27
RBRACE               : 10 11 11 12 13 14 15 16 17
RPAREN               : 10 11 12 16 17
SEMICOLON            : 17 17 51
STRING               : 44
SUMEQUALS            : 
SWITCH               : 12
TIMES                : 25 29
TIMESEQUALS          : 
WHILE                : 16
error                : 

Nonterminals, with rules where they appear

alter_value          : 17 18
condition            : 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38
condition_for        : 17
declaration          : 2 3 10 11 11 13 14 15 16 17
define_break         : 13 14 15
define_cases         : 12 14
define_default       : 12
define_end_of_instruction : 4 18 18 18 23 24 25 26 27 28 29 30 52
expression           : 10 11 16 17 18
op_math              : 5 23 24 25 26
program              : 0
sequence_declaration : 1 2
statement_for        : 8
statement_if         : 6
statement_switch     : 7
statement_while      : 9
type                 : 4
value                : 13 14 46 49 50
variavel             : 4 48 50

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . sequence_declaration
    (2) sequence_declaration -> . declaration sequence_declaration
    (3) sequence_declaration -> . declaration
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . op_math
    (6) declaration -> . statement_if
    (7) declaration -> . statement_switch
    (8) declaration -> . statement_for
    (9) declaration -> . statement_while
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . CHAR
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction
    (10) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (11) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
    (12) statement_switch -> . SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE
    (17) statement_for -> . FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
    (16) statement_while -> . WHILE LPAREN expression RPAREN LBRACE declaration RBRACE

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    CHAR            shift and go to state 12
    ID              shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17

    program                        shift and go to state 1
    sequence_declaration           shift and go to state 2
    declaration                    shift and go to state 3
    type                           shift and go to state 4
    op_math                        shift and go to state 5
    statement_if                   shift and go to state 6
    statement_switch               shift and go to state 7
    statement_for                  shift and go to state 8
    statement_while                shift and go to state 9

state 1

    (0) S' -> program .



state 2

    (1) program -> sequence_declaration .

    $end            reduce using rule 1 (program -> sequence_declaration .)


state 3

    (2) sequence_declaration -> declaration . sequence_declaration
    (3) sequence_declaration -> declaration .
    (2) sequence_declaration -> . declaration sequence_declaration
    (3) sequence_declaration -> . declaration
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . op_math
    (6) declaration -> . statement_if
    (7) declaration -> . statement_switch
    (8) declaration -> . statement_for
    (9) declaration -> . statement_while
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . CHAR
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction
    (10) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (11) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
    (12) statement_switch -> . SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE
    (17) statement_for -> . FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
    (16) statement_while -> . WHILE LPAREN expression RPAREN LBRACE declaration RBRACE

    $end            reduce using rule 3 (sequence_declaration -> declaration .)
    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    CHAR            shift and go to state 12
    ID              shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17

    declaration                    shift and go to state 3
    sequence_declaration           shift and go to state 18
    type                           shift and go to state 4
    op_math                        shift and go to state 5
    statement_if                   shift and go to state 6
    statement_switch               shift and go to state 7
    statement_for                  shift and go to state 8
    statement_while                shift and go to state 9

state 4

    (4) declaration -> type . variavel define_end_of_instruction
    (47) variavel -> . ID
    (48) variavel -> . ID COMMA variavel
    (49) variavel -> . ID ASSIGN value
    (50) variavel -> . ID ASSIGN value COMMA variavel

    ID              shift and go to state 20

    variavel                       shift and go to state 19

state 5

    (5) declaration -> op_math .

    INT             reduce using rule 5 (declaration -> op_math .)
    FLOAT           reduce using rule 5 (declaration -> op_math .)
    CHAR            reduce using rule 5 (declaration -> op_math .)
    ID              reduce using rule 5 (declaration -> op_math .)
    IF              reduce using rule 5 (declaration -> op_math .)
    SWITCH          reduce using rule 5 (declaration -> op_math .)
    FOR             reduce using rule 5 (declaration -> op_math .)
    WHILE           reduce using rule 5 (declaration -> op_math .)
    $end            reduce using rule 5 (declaration -> op_math .)
    RBRACE          reduce using rule 5 (declaration -> op_math .)
    BREAK           reduce using rule 5 (declaration -> op_math .)


state 6

    (6) declaration -> statement_if .

    INT             reduce using rule 6 (declaration -> statement_if .)
    FLOAT           reduce using rule 6 (declaration -> statement_if .)
    CHAR            reduce using rule 6 (declaration -> statement_if .)
    ID              reduce using rule 6 (declaration -> statement_if .)
    IF              reduce using rule 6 (declaration -> statement_if .)
    SWITCH          reduce using rule 6 (declaration -> statement_if .)
    FOR             reduce using rule 6 (declaration -> statement_if .)
    WHILE           reduce using rule 6 (declaration -> statement_if .)
    $end            reduce using rule 6 (declaration -> statement_if .)
    RBRACE          reduce using rule 6 (declaration -> statement_if .)
    BREAK           reduce using rule 6 (declaration -> statement_if .)


state 7

    (7) declaration -> statement_switch .

    INT             reduce using rule 7 (declaration -> statement_switch .)
    FLOAT           reduce using rule 7 (declaration -> statement_switch .)
    CHAR            reduce using rule 7 (declaration -> statement_switch .)
    ID              reduce using rule 7 (declaration -> statement_switch .)
    IF              reduce using rule 7 (declaration -> statement_switch .)
    SWITCH          reduce using rule 7 (declaration -> statement_switch .)
    FOR             reduce using rule 7 (declaration -> statement_switch .)
    WHILE           reduce using rule 7 (declaration -> statement_switch .)
    $end            reduce using rule 7 (declaration -> statement_switch .)
    RBRACE          reduce using rule 7 (declaration -> statement_switch .)
    BREAK           reduce using rule 7 (declaration -> statement_switch .)


state 8

    (8) declaration -> statement_for .

    INT             reduce using rule 8 (declaration -> statement_for .)
    FLOAT           reduce using rule 8 (declaration -> statement_for .)
    CHAR            reduce using rule 8 (declaration -> statement_for .)
    ID              reduce using rule 8 (declaration -> statement_for .)
    IF              reduce using rule 8 (declaration -> statement_for .)
    SWITCH          reduce using rule 8 (declaration -> statement_for .)
    FOR             reduce using rule 8 (declaration -> statement_for .)
    WHILE           reduce using rule 8 (declaration -> statement_for .)
    $end            reduce using rule 8 (declaration -> statement_for .)
    RBRACE          reduce using rule 8 (declaration -> statement_for .)
    BREAK           reduce using rule 8 (declaration -> statement_for .)


state 9

    (9) declaration -> statement_while .

    INT             reduce using rule 9 (declaration -> statement_while .)
    FLOAT           reduce using rule 9 (declaration -> statement_while .)
    CHAR            reduce using rule 9 (declaration -> statement_while .)
    ID              reduce using rule 9 (declaration -> statement_while .)
    IF              reduce using rule 9 (declaration -> statement_while .)
    SWITCH          reduce using rule 9 (declaration -> statement_while .)
    FOR             reduce using rule 9 (declaration -> statement_while .)
    WHILE           reduce using rule 9 (declaration -> statement_while .)
    $end            reduce using rule 9 (declaration -> statement_while .)
    RBRACE          reduce using rule 9 (declaration -> statement_while .)
    BREAK           reduce using rule 9 (declaration -> statement_while .)


state 10

    (39) type -> INT .

    ID              reduce using rule 39 (type -> INT .)


state 11

    (40) type -> FLOAT .

    ID              reduce using rule 40 (type -> FLOAT .)


state 12

    (41) type -> CHAR .

    ID              reduce using rule 41 (type -> CHAR .)


state 13

    (23) op_math -> ID . ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> ID . ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> ID . ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> ID . ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> ID . ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> ID . ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> ID . ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> ID . ASSIGN ID DIVIDE ID define_end_of_instruction

    ASSIGN          shift and go to state 21


state 14

    (10) statement_if -> IF . LPAREN expression RPAREN LBRACE declaration RBRACE
    (11) statement_if -> IF . LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE

    LPAREN          shift and go to state 22


state 15

    (12) statement_switch -> SWITCH . LPAREN ID RPAREN LBRACE define_cases define_default RBRACE

    LPAREN          shift and go to state 23


state 16

    (17) statement_for -> FOR . LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE

    LPAREN          shift and go to state 24


state 17

    (16) statement_while -> WHILE . LPAREN expression RPAREN LBRACE declaration RBRACE

    LPAREN          shift and go to state 25


state 18

    (2) sequence_declaration -> declaration sequence_declaration .

    $end            reduce using rule 2 (sequence_declaration -> declaration sequence_declaration .)


state 19

    (4) declaration -> type variavel . define_end_of_instruction
    (51) define_end_of_instruction -> . SEMICOLON

    SEMICOLON       shift and go to state 27

    define_end_of_instruction      shift and go to state 26

state 20

    (47) variavel -> ID .
    (48) variavel -> ID . COMMA variavel
    (49) variavel -> ID . ASSIGN value
    (50) variavel -> ID . ASSIGN value COMMA variavel

    SEMICOLON       reduce using rule 47 (variavel -> ID .)
    COMMA           shift and go to state 28
    ASSIGN          shift and go to state 29


state 21

    (23) op_math -> ID ASSIGN . ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> ID ASSIGN . ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> ID ASSIGN . ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> ID ASSIGN . ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> ID ASSIGN . ID PLUS ID define_end_of_instruction
    (28) op_math -> ID ASSIGN . ID MINUS ID define_end_of_instruction
    (29) op_math -> ID ASSIGN . ID TIMES ID define_end_of_instruction
    (30) op_math -> ID ASSIGN . ID DIVIDE ID define_end_of_instruction

    ID              shift and go to state 30


state 22

    (10) statement_if -> IF LPAREN . expression RPAREN LBRACE declaration RBRACE
    (11) statement_if -> IF LPAREN . expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
    (31) expression -> . condition MAIOR condition
    (32) expression -> . condition MENOR condition
    (33) expression -> . condition MAIOREQUALS condition
    (34) expression -> . condition MENOREQUALS condition
    (35) expression -> . condition EQUALS condition
    (36) expression -> . condition DIFF condition
    (37) expression -> . condition AND condition
    (38) expression -> . condition OR condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    expression                     shift and go to state 31
    condition                      shift and go to state 32
    value                          shift and go to state 34

state 23

    (12) statement_switch -> SWITCH LPAREN . ID RPAREN LBRACE define_cases define_default RBRACE

    ID              shift and go to state 38


state 24

    (17) statement_for -> FOR LPAREN . condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
    (18) condition_for -> . INT ID ASSIGN NUMBER define_end_of_instruction expression define_end_of_instruction alter_value define_end_of_instruction

    INT             shift and go to state 40

    condition_for                  shift and go to state 39

state 25

    (16) statement_while -> WHILE LPAREN . expression RPAREN LBRACE declaration RBRACE
    (31) expression -> . condition MAIOR condition
    (32) expression -> . condition MENOR condition
    (33) expression -> . condition MAIOREQUALS condition
    (34) expression -> . condition MENOREQUALS condition
    (35) expression -> . condition EQUALS condition
    (36) expression -> . condition DIFF condition
    (37) expression -> . condition AND condition
    (38) expression -> . condition OR condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    expression                     shift and go to state 41
    condition                      shift and go to state 32
    value                          shift and go to state 34

state 26

    (4) declaration -> type variavel define_end_of_instruction .

    INT             reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    FLOAT           reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    CHAR            reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    ID              reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    IF              reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    SWITCH          reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    FOR             reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    WHILE           reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    $end            reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    RBRACE          reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)
    BREAK           reduce using rule 4 (declaration -> type variavel define_end_of_instruction .)


state 27

    (51) define_end_of_instruction -> SEMICOLON .

    INT             reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    FLOAT           reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    CHAR            reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    ID              reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    IF              reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    SWITCH          reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    FOR             reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    WHILE           reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    $end            reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    RBRACE          reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    BREAK           reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    NUMBER          reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    DECIMAL         reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    STRING          reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    PLUS            reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    MINUS           reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)
    SEMICOLON       reduce using rule 51 (define_end_of_instruction -> SEMICOLON .)


state 28

    (48) variavel -> ID COMMA . variavel
    (47) variavel -> . ID
    (48) variavel -> . ID COMMA variavel
    (49) variavel -> . ID ASSIGN value
    (50) variavel -> . ID ASSIGN value COMMA variavel

    ID              shift and go to state 20

    variavel                       shift and go to state 42

state 29

    (49) variavel -> ID ASSIGN . value
    (50) variavel -> ID ASSIGN . value COMMA variavel
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    value                          shift and go to state 43

state 30

    (23) op_math -> ID ASSIGN ID . PLUS ID define_end_of_instruction op_math
    (24) op_math -> ID ASSIGN ID . MINUS ID define_end_of_instruction op_math
    (25) op_math -> ID ASSIGN ID . TIMES ID define_end_of_instruction op_math
    (26) op_math -> ID ASSIGN ID . DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> ID ASSIGN ID . PLUS ID define_end_of_instruction
    (28) op_math -> ID ASSIGN ID . MINUS ID define_end_of_instruction
    (29) op_math -> ID ASSIGN ID . TIMES ID define_end_of_instruction
    (30) op_math -> ID ASSIGN ID . DIVIDE ID define_end_of_instruction

    PLUS            shift and go to state 44
    MINUS           shift and go to state 45
    TIMES           shift and go to state 46
    DIVIDE          shift and go to state 47


state 31

    (10) statement_if -> IF LPAREN expression . RPAREN LBRACE declaration RBRACE
    (11) statement_if -> IF LPAREN expression . RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE

    RPAREN          shift and go to state 48


state 32

    (31) expression -> condition . MAIOR condition
    (32) expression -> condition . MENOR condition
    (33) expression -> condition . MAIOREQUALS condition
    (34) expression -> condition . MENOREQUALS condition
    (35) expression -> condition . EQUALS condition
    (36) expression -> condition . DIFF condition
    (37) expression -> condition . AND condition
    (38) expression -> condition . OR condition

    MAIOR           shift and go to state 49
    MENOR           shift and go to state 50
    MAIOREQUALS     shift and go to state 51
    MENOREQUALS     shift and go to state 52
    EQUALS          shift and go to state 53
    DIFF            shift and go to state 54
    AND             shift and go to state 55
    OR              shift and go to state 56


state 33

    (45) condition -> ID .

    MAIOR           reduce using rule 45 (condition -> ID .)
    MENOR           reduce using rule 45 (condition -> ID .)
    MAIOREQUALS     reduce using rule 45 (condition -> ID .)
    MENOREQUALS     reduce using rule 45 (condition -> ID .)
    EQUALS          reduce using rule 45 (condition -> ID .)
    DIFF            reduce using rule 45 (condition -> ID .)
    AND             reduce using rule 45 (condition -> ID .)
    OR              reduce using rule 45 (condition -> ID .)
    RPAREN          reduce using rule 45 (condition -> ID .)
    SEMICOLON       reduce using rule 45 (condition -> ID .)


state 34

    (46) condition -> value .

    MAIOR           reduce using rule 46 (condition -> value .)
    MENOR           reduce using rule 46 (condition -> value .)
    MAIOREQUALS     reduce using rule 46 (condition -> value .)
    MENOREQUALS     reduce using rule 46 (condition -> value .)
    EQUALS          reduce using rule 46 (condition -> value .)
    DIFF            reduce using rule 46 (condition -> value .)
    AND             reduce using rule 46 (condition -> value .)
    OR              reduce using rule 46 (condition -> value .)
    RPAREN          reduce using rule 46 (condition -> value .)
    SEMICOLON       reduce using rule 46 (condition -> value .)


state 35

    (42) value -> NUMBER .

    MAIOR           reduce using rule 42 (value -> NUMBER .)
    MENOR           reduce using rule 42 (value -> NUMBER .)
    MAIOREQUALS     reduce using rule 42 (value -> NUMBER .)
    MENOREQUALS     reduce using rule 42 (value -> NUMBER .)
    EQUALS          reduce using rule 42 (value -> NUMBER .)
    DIFF            reduce using rule 42 (value -> NUMBER .)
    AND             reduce using rule 42 (value -> NUMBER .)
    OR              reduce using rule 42 (value -> NUMBER .)
    COMMA           reduce using rule 42 (value -> NUMBER .)
    SEMICOLON       reduce using rule 42 (value -> NUMBER .)
    RPAREN          reduce using rule 42 (value -> NUMBER .)
    COLON           reduce using rule 42 (value -> NUMBER .)


state 36

    (43) value -> DECIMAL .

    MAIOR           reduce using rule 43 (value -> DECIMAL .)
    MENOR           reduce using rule 43 (value -> DECIMAL .)
    MAIOREQUALS     reduce using rule 43 (value -> DECIMAL .)
    MENOREQUALS     reduce using rule 43 (value -> DECIMAL .)
    EQUALS          reduce using rule 43 (value -> DECIMAL .)
    DIFF            reduce using rule 43 (value -> DECIMAL .)
    AND             reduce using rule 43 (value -> DECIMAL .)
    OR              reduce using rule 43 (value -> DECIMAL .)
    COMMA           reduce using rule 43 (value -> DECIMAL .)
    SEMICOLON       reduce using rule 43 (value -> DECIMAL .)
    RPAREN          reduce using rule 43 (value -> DECIMAL .)
    COLON           reduce using rule 43 (value -> DECIMAL .)


state 37

    (44) value -> STRING .

    MAIOR           reduce using rule 44 (value -> STRING .)
    MENOR           reduce using rule 44 (value -> STRING .)
    MAIOREQUALS     reduce using rule 44 (value -> STRING .)
    MENOREQUALS     reduce using rule 44 (value -> STRING .)
    EQUALS          reduce using rule 44 (value -> STRING .)
    DIFF            reduce using rule 44 (value -> STRING .)
    AND             reduce using rule 44 (value -> STRING .)
    OR              reduce using rule 44 (value -> STRING .)
    COMMA           reduce using rule 44 (value -> STRING .)
    SEMICOLON       reduce using rule 44 (value -> STRING .)
    RPAREN          reduce using rule 44 (value -> STRING .)
    COLON           reduce using rule 44 (value -> STRING .)


state 38

    (12) statement_switch -> SWITCH LPAREN ID . RPAREN LBRACE define_cases define_default RBRACE

    RPAREN          shift and go to state 57


state 39

    (17) statement_for -> FOR LPAREN condition_for . SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE

    SEMICOLON       shift and go to state 58


state 40

    (18) condition_for -> INT . ID ASSIGN NUMBER define_end_of_instruction expression define_end_of_instruction alter_value define_end_of_instruction

    ID              shift and go to state 59


state 41

    (16) statement_while -> WHILE LPAREN expression . RPAREN LBRACE declaration RBRACE

    RPAREN          shift and go to state 60


state 42

    (48) variavel -> ID COMMA variavel .

    SEMICOLON       reduce using rule 48 (variavel -> ID COMMA variavel .)


state 43

    (49) variavel -> ID ASSIGN value .
    (50) variavel -> ID ASSIGN value . COMMA variavel

    SEMICOLON       reduce using rule 49 (variavel -> ID ASSIGN value .)
    COMMA           shift and go to state 61


state 44

    (23) op_math -> ID ASSIGN ID PLUS . ID define_end_of_instruction op_math
    (27) op_math -> ID ASSIGN ID PLUS . ID define_end_of_instruction

    ID              shift and go to state 62


state 45

    (24) op_math -> ID ASSIGN ID MINUS . ID define_end_of_instruction op_math
    (28) op_math -> ID ASSIGN ID MINUS . ID define_end_of_instruction

    ID              shift and go to state 63


state 46

    (25) op_math -> ID ASSIGN ID TIMES . ID define_end_of_instruction op_math
    (29) op_math -> ID ASSIGN ID TIMES . ID define_end_of_instruction

    ID              shift and go to state 64


state 47

    (26) op_math -> ID ASSIGN ID DIVIDE . ID define_end_of_instruction op_math
    (30) op_math -> ID ASSIGN ID DIVIDE . ID define_end_of_instruction

    ID              shift and go to state 65


state 48

    (10) statement_if -> IF LPAREN expression RPAREN . LBRACE declaration RBRACE
    (11) statement_if -> IF LPAREN expression RPAREN . LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE

    LBRACE          shift and go to state 66


state 49

    (31) expression -> condition MAIOR . condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    condition                      shift and go to state 67
    value                          shift and go to state 34

state 50

    (32) expression -> condition MENOR . condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    condition                      shift and go to state 68
    value                          shift and go to state 34

state 51

    (33) expression -> condition MAIOREQUALS . condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    condition                      shift and go to state 69
    value                          shift and go to state 34

state 52

    (34) expression -> condition MENOREQUALS . condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    condition                      shift and go to state 70
    value                          shift and go to state 34

state 53

    (35) expression -> condition EQUALS . condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    condition                      shift and go to state 71
    value                          shift and go to state 34

state 54

    (36) expression -> condition DIFF . condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    condition                      shift and go to state 72
    value                          shift and go to state 34

state 55

    (37) expression -> condition AND . condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    condition                      shift and go to state 73
    value                          shift and go to state 34

state 56

    (38) expression -> condition OR . condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    condition                      shift and go to state 74
    value                          shift and go to state 34

state 57

    (12) statement_switch -> SWITCH LPAREN ID RPAREN . LBRACE define_cases define_default RBRACE

    LBRACE          shift and go to state 75


state 58

    (17) statement_for -> FOR LPAREN condition_for SEMICOLON . expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
    (31) expression -> . condition MAIOR condition
    (32) expression -> . condition MENOR condition
    (33) expression -> . condition MAIOREQUALS condition
    (34) expression -> . condition MENOREQUALS condition
    (35) expression -> . condition EQUALS condition
    (36) expression -> . condition DIFF condition
    (37) expression -> . condition AND condition
    (38) expression -> . condition OR condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    expression                     shift and go to state 76
    condition                      shift and go to state 32
    value                          shift and go to state 34

state 59

    (18) condition_for -> INT ID . ASSIGN NUMBER define_end_of_instruction expression define_end_of_instruction alter_value define_end_of_instruction

    ASSIGN          shift and go to state 77


state 60

    (16) statement_while -> WHILE LPAREN expression RPAREN . LBRACE declaration RBRACE

    LBRACE          shift and go to state 78


state 61

    (50) variavel -> ID ASSIGN value COMMA . variavel
    (47) variavel -> . ID
    (48) variavel -> . ID COMMA variavel
    (49) variavel -> . ID ASSIGN value
    (50) variavel -> . ID ASSIGN value COMMA variavel

    ID              shift and go to state 20

    variavel                       shift and go to state 79

state 62

    (23) op_math -> ID ASSIGN ID PLUS ID . define_end_of_instruction op_math
    (27) op_math -> ID ASSIGN ID PLUS ID . define_end_of_instruction
    (51) define_end_of_instruction -> . SEMICOLON

    SEMICOLON       shift and go to state 27

    define_end_of_instruction      shift and go to state 80

state 63

    (24) op_math -> ID ASSIGN ID MINUS ID . define_end_of_instruction op_math
    (28) op_math -> ID ASSIGN ID MINUS ID . define_end_of_instruction
    (51) define_end_of_instruction -> . SEMICOLON

    SEMICOLON       shift and go to state 27

    define_end_of_instruction      shift and go to state 81

state 64

    (25) op_math -> ID ASSIGN ID TIMES ID . define_end_of_instruction op_math
    (29) op_math -> ID ASSIGN ID TIMES ID . define_end_of_instruction
    (51) define_end_of_instruction -> . SEMICOLON

    SEMICOLON       shift and go to state 27

    define_end_of_instruction      shift and go to state 82

state 65

    (26) op_math -> ID ASSIGN ID DIVIDE ID . define_end_of_instruction op_math
    (30) op_math -> ID ASSIGN ID DIVIDE ID . define_end_of_instruction
    (51) define_end_of_instruction -> . SEMICOLON

    SEMICOLON       shift and go to state 27

    define_end_of_instruction      shift and go to state 83

state 66

    (10) statement_if -> IF LPAREN expression RPAREN LBRACE . declaration RBRACE
    (11) statement_if -> IF LPAREN expression RPAREN LBRACE . declaration RBRACE ELSE LBRACE declaration RBRACE
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . op_math
    (6) declaration -> . statement_if
    (7) declaration -> . statement_switch
    (8) declaration -> . statement_for
    (9) declaration -> . statement_while
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . CHAR
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction
    (10) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (11) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
    (12) statement_switch -> . SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE
    (17) statement_for -> . FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
    (16) statement_while -> . WHILE LPAREN expression RPAREN LBRACE declaration RBRACE

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    CHAR            shift and go to state 12
    ID              shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17

    declaration                    shift and go to state 84
    type                           shift and go to state 4
    op_math                        shift and go to state 5
    statement_if                   shift and go to state 6
    statement_switch               shift and go to state 7
    statement_for                  shift and go to state 8
    statement_while                shift and go to state 9

state 67

    (31) expression -> condition MAIOR condition .

    RPAREN          reduce using rule 31 (expression -> condition MAIOR condition .)
    SEMICOLON       reduce using rule 31 (expression -> condition MAIOR condition .)


state 68

    (32) expression -> condition MENOR condition .

    RPAREN          reduce using rule 32 (expression -> condition MENOR condition .)
    SEMICOLON       reduce using rule 32 (expression -> condition MENOR condition .)


state 69

    (33) expression -> condition MAIOREQUALS condition .

    RPAREN          reduce using rule 33 (expression -> condition MAIOREQUALS condition .)
    SEMICOLON       reduce using rule 33 (expression -> condition MAIOREQUALS condition .)


state 70

    (34) expression -> condition MENOREQUALS condition .

    RPAREN          reduce using rule 34 (expression -> condition MENOREQUALS condition .)
    SEMICOLON       reduce using rule 34 (expression -> condition MENOREQUALS condition .)


state 71

    (35) expression -> condition EQUALS condition .

    RPAREN          reduce using rule 35 (expression -> condition EQUALS condition .)
    SEMICOLON       reduce using rule 35 (expression -> condition EQUALS condition .)


state 72

    (36) expression -> condition DIFF condition .

    RPAREN          reduce using rule 36 (expression -> condition DIFF condition .)
    SEMICOLON       reduce using rule 36 (expression -> condition DIFF condition .)


state 73

    (37) expression -> condition AND condition .

    RPAREN          reduce using rule 37 (expression -> condition AND condition .)
    SEMICOLON       reduce using rule 37 (expression -> condition AND condition .)


state 74

    (38) expression -> condition OR condition .

    RPAREN          reduce using rule 38 (expression -> condition OR condition .)
    SEMICOLON       reduce using rule 38 (expression -> condition OR condition .)


state 75

    (12) statement_switch -> SWITCH LPAREN ID RPAREN LBRACE . define_cases define_default RBRACE
    (13) define_cases -> . CASE value COLON LBRACE declaration define_break RBRACE
    (14) define_cases -> . CASE value COLON LBRACE declaration define_break RBRACE define_cases

    CASE            shift and go to state 86

    define_cases                   shift and go to state 85

state 76

    (17) statement_for -> FOR LPAREN condition_for SEMICOLON expression . SEMICOLON alter_value RPAREN LBRACE declaration RBRACE

    SEMICOLON       shift and go to state 87


state 77

    (18) condition_for -> INT ID ASSIGN . NUMBER define_end_of_instruction expression define_end_of_instruction alter_value define_end_of_instruction

    NUMBER          shift and go to state 88


state 78

    (16) statement_while -> WHILE LPAREN expression RPAREN LBRACE . declaration RBRACE
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . op_math
    (6) declaration -> . statement_if
    (7) declaration -> . statement_switch
    (8) declaration -> . statement_for
    (9) declaration -> . statement_while
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . CHAR
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction
    (10) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (11) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
    (12) statement_switch -> . SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE
    (17) statement_for -> . FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
    (16) statement_while -> . WHILE LPAREN expression RPAREN LBRACE declaration RBRACE

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    CHAR            shift and go to state 12
    ID              shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17

    declaration                    shift and go to state 89
    type                           shift and go to state 4
    op_math                        shift and go to state 5
    statement_if                   shift and go to state 6
    statement_switch               shift and go to state 7
    statement_for                  shift and go to state 8
    statement_while                shift and go to state 9

state 79

    (50) variavel -> ID ASSIGN value COMMA variavel .

    SEMICOLON       reduce using rule 50 (variavel -> ID ASSIGN value COMMA variavel .)


state 80

    (23) op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction . op_math
    (27) op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction

  ! shift/reduce conflict for ID resolved as shift
    INT             reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .)
    FLOAT           reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .)
    CHAR            reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .)
    IF              reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .)
    SWITCH          reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .)
    FOR             reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .)
    WHILE           reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .)
    $end            reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .)
    RBRACE          reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .)
    BREAK           reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .)
    ID              shift and go to state 13

  ! ID              [ reduce using rule 27 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction .) ]

    op_math                        shift and go to state 90

state 81

    (24) op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction . op_math
    (28) op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction

  ! shift/reduce conflict for ID resolved as shift
    INT             reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .)
    FLOAT           reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .)
    CHAR            reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .)
    IF              reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .)
    SWITCH          reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .)
    FOR             reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .)
    WHILE           reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .)
    $end            reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .)
    RBRACE          reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .)
    BREAK           reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .)
    ID              shift and go to state 13

  ! ID              [ reduce using rule 28 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction .) ]

    op_math                        shift and go to state 91

state 82

    (25) op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction . op_math
    (29) op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction

  ! shift/reduce conflict for ID resolved as shift
    INT             reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .)
    FLOAT           reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .)
    CHAR            reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .)
    IF              reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .)
    SWITCH          reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .)
    FOR             reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .)
    WHILE           reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .)
    $end            reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .)
    RBRACE          reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .)
    BREAK           reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .)
    ID              shift and go to state 13

  ! ID              [ reduce using rule 29 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction .) ]

    op_math                        shift and go to state 92

state 83

    (26) op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction . op_math
    (30) op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction

  ! shift/reduce conflict for ID resolved as shift
    INT             reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .)
    FLOAT           reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .)
    CHAR            reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .)
    IF              reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .)
    SWITCH          reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .)
    FOR             reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .)
    WHILE           reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .)
    $end            reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .)
    RBRACE          reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .)
    BREAK           reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .)
    ID              shift and go to state 13

  ! ID              [ reduce using rule 30 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction .) ]

    op_math                        shift and go to state 93

state 84

    (10) statement_if -> IF LPAREN expression RPAREN LBRACE declaration . RBRACE
    (11) statement_if -> IF LPAREN expression RPAREN LBRACE declaration . RBRACE ELSE LBRACE declaration RBRACE

    RBRACE          shift and go to state 94


state 85

    (12) statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases . define_default RBRACE
    (15) define_default -> . DEFAULT COLON LBRACE declaration define_break RBRACE

    DEFAULT         shift and go to state 96

    define_default                 shift and go to state 95

state 86

    (13) define_cases -> CASE . value COLON LBRACE declaration define_break RBRACE
    (14) define_cases -> CASE . value COLON LBRACE declaration define_break RBRACE define_cases
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    value                          shift and go to state 97

state 87

    (17) statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON . alter_value RPAREN LBRACE declaration RBRACE
    (19) alter_value -> . ID PLUS PLUS
    (20) alter_value -> . PLUS PLUS ID
    (21) alter_value -> . ID MINUS MINUS
    (22) alter_value -> . MINUS MINUS ID

    ID              shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101

    alter_value                    shift and go to state 98

state 88

    (18) condition_for -> INT ID ASSIGN NUMBER . define_end_of_instruction expression define_end_of_instruction alter_value define_end_of_instruction
    (51) define_end_of_instruction -> . SEMICOLON

    SEMICOLON       shift and go to state 27

    define_end_of_instruction      shift and go to state 102

state 89

    (16) statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration . RBRACE

    RBRACE          shift and go to state 103


state 90

    (23) op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .

    INT             reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)
    FLOAT           reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)
    CHAR            reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)
    ID              reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)
    IF              reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)
    SWITCH          reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)
    FOR             reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)
    WHILE           reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)
    $end            reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)
    RBRACE          reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)
    BREAK           reduce using rule 23 (op_math -> ID ASSIGN ID PLUS ID define_end_of_instruction op_math .)


state 91

    (24) op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .

    INT             reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)
    FLOAT           reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)
    CHAR            reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)
    ID              reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)
    IF              reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)
    SWITCH          reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)
    FOR             reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)
    WHILE           reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)
    $end            reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)
    RBRACE          reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)
    BREAK           reduce using rule 24 (op_math -> ID ASSIGN ID MINUS ID define_end_of_instruction op_math .)


state 92

    (25) op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .

    INT             reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)
    FLOAT           reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)
    CHAR            reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)
    ID              reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)
    IF              reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)
    SWITCH          reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)
    FOR             reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)
    WHILE           reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)
    $end            reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)
    RBRACE          reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)
    BREAK           reduce using rule 25 (op_math -> ID ASSIGN ID TIMES ID define_end_of_instruction op_math .)


state 93

    (26) op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .

    INT             reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)
    FLOAT           reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)
    CHAR            reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)
    ID              reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)
    IF              reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)
    SWITCH          reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)
    FOR             reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)
    WHILE           reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)
    $end            reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)
    RBRACE          reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)
    BREAK           reduce using rule 26 (op_math -> ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math .)


state 94

    (10) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .
    (11) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE . ELSE LBRACE declaration RBRACE

    INT             reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    FLOAT           reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    CHAR            reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    ID              reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    IF              reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    SWITCH          reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    FOR             reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    WHILE           reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    $end            reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    RBRACE          reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    BREAK           reduce using rule 10 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE .)
    ELSE            shift and go to state 104


state 95

    (12) statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default . RBRACE

    RBRACE          shift and go to state 105


state 96

    (15) define_default -> DEFAULT . COLON LBRACE declaration define_break RBRACE

    COLON           shift and go to state 106


state 97

    (13) define_cases -> CASE value . COLON LBRACE declaration define_break RBRACE
    (14) define_cases -> CASE value . COLON LBRACE declaration define_break RBRACE define_cases

    COLON           shift and go to state 107


state 98

    (17) statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value . RPAREN LBRACE declaration RBRACE

    RPAREN          shift and go to state 108


state 99

    (19) alter_value -> ID . PLUS PLUS
    (21) alter_value -> ID . MINUS MINUS

    PLUS            shift and go to state 109
    MINUS           shift and go to state 110


state 100

    (20) alter_value -> PLUS . PLUS ID

    PLUS            shift and go to state 111


state 101

    (22) alter_value -> MINUS . MINUS ID

    MINUS           shift and go to state 112


state 102

    (18) condition_for -> INT ID ASSIGN NUMBER define_end_of_instruction . expression define_end_of_instruction alter_value define_end_of_instruction
    (31) expression -> . condition MAIOR condition
    (32) expression -> . condition MENOR condition
    (33) expression -> . condition MAIOREQUALS condition
    (34) expression -> . condition MENOREQUALS condition
    (35) expression -> . condition EQUALS condition
    (36) expression -> . condition DIFF condition
    (37) expression -> . condition AND condition
    (38) expression -> . condition OR condition
    (45) condition -> . ID
    (46) condition -> . value
    (42) value -> . NUMBER
    (43) value -> . DECIMAL
    (44) value -> . STRING

    ID              shift and go to state 33
    NUMBER          shift and go to state 35
    DECIMAL         shift and go to state 36
    STRING          shift and go to state 37

    expression                     shift and go to state 113
    condition                      shift and go to state 32
    value                          shift and go to state 34

state 103

    (16) statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .

    INT             reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)
    FLOAT           reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)
    CHAR            reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)
    ID              reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)
    IF              reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)
    SWITCH          reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)
    FOR             reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)
    WHILE           reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)
    $end            reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)
    RBRACE          reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)
    BREAK           reduce using rule 16 (statement_while -> WHILE LPAREN expression RPAREN LBRACE declaration RBRACE .)


state 104

    (11) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE . LBRACE declaration RBRACE

    LBRACE          shift and go to state 114


state 105

    (12) statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .

    INT             reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)
    FLOAT           reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)
    CHAR            reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)
    ID              reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)
    IF              reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)
    SWITCH          reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)
    FOR             reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)
    WHILE           reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)
    $end            reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)
    RBRACE          reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)
    BREAK           reduce using rule 12 (statement_switch -> SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE .)


state 106

    (15) define_default -> DEFAULT COLON . LBRACE declaration define_break RBRACE

    LBRACE          shift and go to state 115


state 107

    (13) define_cases -> CASE value COLON . LBRACE declaration define_break RBRACE
    (14) define_cases -> CASE value COLON . LBRACE declaration define_break RBRACE define_cases

    LBRACE          shift and go to state 116


state 108

    (17) statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN . LBRACE declaration RBRACE

    LBRACE          shift and go to state 117


state 109

    (19) alter_value -> ID PLUS . PLUS

    PLUS            shift and go to state 118


state 110

    (21) alter_value -> ID MINUS . MINUS

    MINUS           shift and go to state 119


state 111

    (20) alter_value -> PLUS PLUS . ID

    ID              shift and go to state 120


state 112

    (22) alter_value -> MINUS MINUS . ID

    ID              shift and go to state 121


state 113

    (18) condition_for -> INT ID ASSIGN NUMBER define_end_of_instruction expression . define_end_of_instruction alter_value define_end_of_instruction
    (51) define_end_of_instruction -> . SEMICOLON

    SEMICOLON       shift and go to state 27

    define_end_of_instruction      shift and go to state 122

state 114

    (11) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE . declaration RBRACE
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . op_math
    (6) declaration -> . statement_if
    (7) declaration -> . statement_switch
    (8) declaration -> . statement_for
    (9) declaration -> . statement_while
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . CHAR
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction
    (10) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (11) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
    (12) statement_switch -> . SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE
    (17) statement_for -> . FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
    (16) statement_while -> . WHILE LPAREN expression RPAREN LBRACE declaration RBRACE

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    CHAR            shift and go to state 12
    ID              shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17

    declaration                    shift and go to state 123
    type                           shift and go to state 4
    op_math                        shift and go to state 5
    statement_if                   shift and go to state 6
    statement_switch               shift and go to state 7
    statement_for                  shift and go to state 8
    statement_while                shift and go to state 9

state 115

    (15) define_default -> DEFAULT COLON LBRACE . declaration define_break RBRACE
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . op_math
    (6) declaration -> . statement_if
    (7) declaration -> . statement_switch
    (8) declaration -> . statement_for
    (9) declaration -> . statement_while
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . CHAR
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction
    (10) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (11) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
    (12) statement_switch -> . SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE
    (17) statement_for -> . FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
    (16) statement_while -> . WHILE LPAREN expression RPAREN LBRACE declaration RBRACE

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    CHAR            shift and go to state 12
    ID              shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17

    declaration                    shift and go to state 124
    type                           shift and go to state 4
    op_math                        shift and go to state 5
    statement_if                   shift and go to state 6
    statement_switch               shift and go to state 7
    statement_for                  shift and go to state 8
    statement_while                shift and go to state 9

state 116

    (13) define_cases -> CASE value COLON LBRACE . declaration define_break RBRACE
    (14) define_cases -> CASE value COLON LBRACE . declaration define_break RBRACE define_cases
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . op_math
    (6) declaration -> . statement_if
    (7) declaration -> . statement_switch
    (8) declaration -> . statement_for
    (9) declaration -> . statement_while
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . CHAR
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction
    (10) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (11) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
    (12) statement_switch -> . SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE
    (17) statement_for -> . FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
    (16) statement_while -> . WHILE LPAREN expression RPAREN LBRACE declaration RBRACE

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    CHAR            shift and go to state 12
    ID              shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17

    declaration                    shift and go to state 125
    type                           shift and go to state 4
    op_math                        shift and go to state 5
    statement_if                   shift and go to state 6
    statement_switch               shift and go to state 7
    statement_for                  shift and go to state 8
    statement_while                shift and go to state 9

state 117

    (17) statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE . declaration RBRACE
    (4) declaration -> . type variavel define_end_of_instruction
    (5) declaration -> . op_math
    (6) declaration -> . statement_if
    (7) declaration -> . statement_switch
    (8) declaration -> . statement_for
    (9) declaration -> . statement_while
    (39) type -> . INT
    (40) type -> . FLOAT
    (41) type -> . CHAR
    (23) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction op_math
    (24) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction op_math
    (25) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction op_math
    (26) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction op_math
    (27) op_math -> . ID ASSIGN ID PLUS ID define_end_of_instruction
    (28) op_math -> . ID ASSIGN ID MINUS ID define_end_of_instruction
    (29) op_math -> . ID ASSIGN ID TIMES ID define_end_of_instruction
    (30) op_math -> . ID ASSIGN ID DIVIDE ID define_end_of_instruction
    (10) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE
    (11) statement_if -> . IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE
    (12) statement_switch -> . SWITCH LPAREN ID RPAREN LBRACE define_cases define_default RBRACE
    (17) statement_for -> . FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE
    (16) statement_while -> . WHILE LPAREN expression RPAREN LBRACE declaration RBRACE

    INT             shift and go to state 10
    FLOAT           shift and go to state 11
    CHAR            shift and go to state 12
    ID              shift and go to state 13
    IF              shift and go to state 14
    SWITCH          shift and go to state 15
    FOR             shift and go to state 16
    WHILE           shift and go to state 17

    declaration                    shift and go to state 126
    type                           shift and go to state 4
    op_math                        shift and go to state 5
    statement_if                   shift and go to state 6
    statement_switch               shift and go to state 7
    statement_for                  shift and go to state 8
    statement_while                shift and go to state 9

state 118

    (19) alter_value -> ID PLUS PLUS .

    RPAREN          reduce using rule 19 (alter_value -> ID PLUS PLUS .)
    SEMICOLON       reduce using rule 19 (alter_value -> ID PLUS PLUS .)


state 119

    (21) alter_value -> ID MINUS MINUS .

    RPAREN          reduce using rule 21 (alter_value -> ID MINUS MINUS .)
    SEMICOLON       reduce using rule 21 (alter_value -> ID MINUS MINUS .)


state 120

    (20) alter_value -> PLUS PLUS ID .

    RPAREN          reduce using rule 20 (alter_value -> PLUS PLUS ID .)
    SEMICOLON       reduce using rule 20 (alter_value -> PLUS PLUS ID .)


state 121

    (22) alter_value -> MINUS MINUS ID .

    RPAREN          reduce using rule 22 (alter_value -> MINUS MINUS ID .)
    SEMICOLON       reduce using rule 22 (alter_value -> MINUS MINUS ID .)


state 122

    (18) condition_for -> INT ID ASSIGN NUMBER define_end_of_instruction expression define_end_of_instruction . alter_value define_end_of_instruction
    (19) alter_value -> . ID PLUS PLUS
    (20) alter_value -> . PLUS PLUS ID
    (21) alter_value -> . ID MINUS MINUS
    (22) alter_value -> . MINUS MINUS ID

    ID              shift and go to state 99
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101

    alter_value                    shift and go to state 127

state 123

    (11) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration . RBRACE

    RBRACE          shift and go to state 128


state 124

    (15) define_default -> DEFAULT COLON LBRACE declaration . define_break RBRACE
    (52) define_break -> . BREAK define_end_of_instruction

    BREAK           shift and go to state 130

    define_break                   shift and go to state 129

state 125

    (13) define_cases -> CASE value COLON LBRACE declaration . define_break RBRACE
    (14) define_cases -> CASE value COLON LBRACE declaration . define_break RBRACE define_cases
    (52) define_break -> . BREAK define_end_of_instruction

    BREAK           shift and go to state 130

    define_break                   shift and go to state 131

state 126

    (17) statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration . RBRACE

    RBRACE          shift and go to state 132


state 127

    (18) condition_for -> INT ID ASSIGN NUMBER define_end_of_instruction expression define_end_of_instruction alter_value . define_end_of_instruction
    (51) define_end_of_instruction -> . SEMICOLON

    SEMICOLON       shift and go to state 27

    define_end_of_instruction      shift and go to state 133

state 128

    (11) statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .

    INT             reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    FLOAT           reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    CHAR            reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    ID              reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    IF              reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    SWITCH          reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    FOR             reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    WHILE           reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    $end            reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    RBRACE          reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)
    BREAK           reduce using rule 11 (statement_if -> IF LPAREN expression RPAREN LBRACE declaration RBRACE ELSE LBRACE declaration RBRACE .)


state 129

    (15) define_default -> DEFAULT COLON LBRACE declaration define_break . RBRACE

    RBRACE          shift and go to state 134


state 130

    (52) define_break -> BREAK . define_end_of_instruction
    (51) define_end_of_instruction -> . SEMICOLON

    SEMICOLON       shift and go to state 27

    define_end_of_instruction      shift and go to state 135

state 131

    (13) define_cases -> CASE value COLON LBRACE declaration define_break . RBRACE
    (14) define_cases -> CASE value COLON LBRACE declaration define_break . RBRACE define_cases

    RBRACE          shift and go to state 136


state 132

    (17) statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .

    INT             reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)
    FLOAT           reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)
    CHAR            reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)
    ID              reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)
    IF              reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)
    SWITCH          reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)
    FOR             reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)
    WHILE           reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)
    $end            reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)
    RBRACE          reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)
    BREAK           reduce using rule 17 (statement_for -> FOR LPAREN condition_for SEMICOLON expression SEMICOLON alter_value RPAREN LBRACE declaration RBRACE .)


state 133

    (18) condition_for -> INT ID ASSIGN NUMBER define_end_of_instruction expression define_end_of_instruction alter_value define_end_of_instruction .

    SEMICOLON       reduce using rule 18 (condition_for -> INT ID ASSIGN NUMBER define_end_of_instruction expression define_end_of_instruction alter_value define_end_of_instruction .)


state 134

    (15) define_default -> DEFAULT COLON LBRACE declaration define_break RBRACE .

    RBRACE          reduce using rule 15 (define_default -> DEFAULT COLON LBRACE declaration define_break RBRACE .)


state 135

    (52) define_break -> BREAK define_end_of_instruction .

    RBRACE          reduce using rule 52 (define_break -> BREAK define_end_of_instruction .)


state 136

    (13) define_cases -> CASE value COLON LBRACE declaration define_break RBRACE .
    (14) define_cases -> CASE value COLON LBRACE declaration define_break RBRACE . define_cases
    (13) define_cases -> . CASE value COLON LBRACE declaration define_break RBRACE
    (14) define_cases -> . CASE value COLON LBRACE declaration define_break RBRACE define_cases

    DEFAULT         reduce using rule 13 (define_cases -> CASE value COLON LBRACE declaration define_break RBRACE .)
    CASE            shift and go to state 86

    define_cases                   shift and go to state 137

state 137

    (14) define_cases -> CASE value COLON LBRACE declaration define_break RBRACE define_cases .

    DEFAULT         reduce using rule 14 (define_cases -> CASE value COLON LBRACE declaration define_break RBRACE define_cases .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 80 resolved as shift
WARNING: shift/reduce conflict for ID in state 81 resolved as shift
WARNING: shift/reduce conflict for ID in state 82 resolved as shift
WARNING: shift/reduce conflict for ID in state 83 resolved as shift
